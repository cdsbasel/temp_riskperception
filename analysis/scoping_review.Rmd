---
# DESCRIPTION -------------------------------------------------------------

# In this script we visualize the data for the scoping review.

# Author(s): Amanda Holzer(1), Arzie Bajrami(1), Rui Mata(1)
# (1)Centre for Cognitive and Decision Sciences, Faculty of Psychology, University of Basel.

title: "Visualizations for Scoping Review"
author: "Amanda Holzer, Arzie Bajrami"
date: "2024-04-09"
output: html_document
---

```{r setup, include=FALSE}
# PACKAGES ---------------------------------------------------------------
#load packages 
#install.packages("dplyr")
#install.packages("here")
#install.packages("viridis")
#install.packages("tidyverse")
#install.packages("devtools")
devtools::install_github("dustinfife/flexplot")
library(dplyr)
library(here)
library(readr)
library(tidyverse)
library(ggplot2)
library(knitr)
library(viridis)
library(devtools)
library(flexplot)

# PATH ---------------------------------------------------------------
#set working directory
setwd(here())
here("data/final.csv")
getwd()

# DATA ---------------------------------------------------------------
#Import the data set
df_final <- read_csv(here("data", "final.csv"))
```

## Study Characteristics
```{r}
## Study design
#Create table
table_study_design <- table(df_final$study_design)
print(table_study_design)
prop.table(table_study_design) * 100 #percentage of study design
```

```{r}
## Time measurement
df_final <- df_final %>%
  mutate(measure = ifelse(times_measured_1 == 2, "2",
                          ifelse(times_measured_1 == 3, "3", "3+")))

#percentage distribution 
percentage_distribution <- df_final %>%
  group_by(measure) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100)

print(percentage_distribution)
```

```{r}
## Measurement type
#Create table
table_measured <- table(df_final$measured_1)
prop.table(table_measured_1) * 100 #percentage of measurement type
```

```{r}
## Intervention
# Rename values for intervention_yesno_1
df_final <- df_final %>%
  mutate(
    intervention_yesno_1 = ifelse(intervention_yesno_1 == 0, "No Intervention", "Intervention")
  )

#Create table
table_intervention <- table(df_final$intervention_yesno_1)
prop.table(table_intervention) * 100 #percentage of measurement type
```

```{r}
## Exposure
# Rename values for exposure_yesno_1
df_final <- df_final %>%
  mutate(
    exposure_yesno_1 = ifelse(exposure_yesno_1 == 0, "No Exposure", "Intervention")
  )

#Create table
table_exposure <- table(df_final$exposure_yesno_1)
prop.table(table_exposure) * 100 #percentage of measurement type
```

```{r}
## data availability
df_final <- df_final %>%
  mutate(
    data_availability = ifelse(is.na(data_availability), "No Data Available", "Data Available")
  )

# percentage distribution
percentage_distribution <- df_final %>%
  count(data_availability) %>%
  mutate(percentage = n / sum(n) * 100)

```


```{r}
### plot domains with study design
### Function to create a single horizontal bar plot for counts of 1
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Arrange levels of 'variable' by count in ascending order
  df_long$variable <- factor(df_long$variable, levels = names(sort(table(df_long$variable), decreasing = FALSE)))
  
  # Define custom colors using hex color codes
  custom_colors <- c("#440154", "#22A884")  # Hex color codes without alpha
  
  # Plotting the horizontal bar plot using ggplot2
  ggplot(df_long, aes(x = value, y = variable, fill = study_design)) +
    geom_bar(stat = "identity", position = position_stack(reverse = TRUE), color = NA) +  # Reverse the stacking order
    scale_fill_manual(values = setNames(custom_colors, unique(df_long$study_design))) +  # Apply custom colors to study_design levels
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank()) +  # Remove grid lines and borders
    labs(x = "Number of Studies", y = NULL, title = NULL) +  # Remove y-axis label and title
    xlab("Number of Studies")  # Set x-axis label
}
# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
###plot domain with measurement points-----
#create measurement category with 2, 3, and 3+
df_final <- df_final %>%
  mutate(measure = ifelse(times_measured_1 == 2, "2",
                          ifelse(times_measured_1 == 3, "3", "3+")))

# Function to create a single horizontal bar plot for counts of 1
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Arrange levels of 'variable' by count in ascending order
  df_long$variable <- factor(df_long$variable, levels = names(sort(table(df_long$variable), decreasing = FALSE)))
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = value, y = variable, fill = measure)) +
    geom_bar(stat = "identity", position = position_stack(reverse = TRUE), color = NA) +  # Reverse the stacking order
    scale_fill_viridis_d() +  # Use Viridis color palette for measure variable
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank()) +  # Remove grid lines and borders
    labs(x = "Number of Studies", y = NULL, title = NULL) +  # Remove y-axis label and title
    xlab("Number of Studies")  # Set x-axis label
}

# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
##make the bars a 100 percent. And not count anymore
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Set the order of the levels for the 'measure' column
  df_long$measure <- factor(df_long$measure, levels = c("3+", "3", "2"))
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = as.factor(measure))) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Measurement Points")  # Use Viridis color palette and customize legend title
}

# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
#kind of risk (risk, concern, worry)
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = as.factor(risk_1))) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Risk Categories")  # Use Viridis color palette and customize legend title
}

# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
#### how measured (scale, single item, etc.)-----
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = as.factor(measured_1))) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Measurement Categories")  # Use Viridis color palette and customize legend title
}

# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
#exposure and intervention
create_combined_horizontal_bar <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Create a new factor combining intervention and exposure columns
  df_long$factor_combined <- interaction(df_long$intervention_yesno_1, df_long$exposure_yesno_1)
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = factor_combined)) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Intervention and Exposure (Yes/No)", labels = c(
      "No Intervention, No Exposure",
      "No Intervention, Exposure",
      "Intervention, No Exposure",
      "Intervention, Exposure"
    ))  # Use Viridis color palette and customize legend title
}

# Apply the function to df_final
create_combined_horizontal_bar(df_final)
```


```{r}
# data availability
# Create a new column data_availability_1
df_final$data_availability_1 <- as.integer(!is.na(df_final$data_availability) & df_final$data_availability != "")

create_combined_horizontal_bar_data <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = as.factor(data_availability_1))) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Data Availability", labels = c(
      "No Data",
      "Data Available"
    ))  # Use Viridis color palette and customize legend title
}

# Apply the function to df_final
create_combined_horizontal_bar_data(df_final)
```


```{r}
##density plots----- 
###number of studies----
# Function to create separate density plots for each category
create_separate_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the separate density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = times_measured_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_wrap(~category, scales = "free_y") +  # Separate plots for each category
    scale_fill_viridis_d(name = "Category") +  # Use Viridis color palette and set legend title
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank()) +  # Remove grid lines and borders
    labs(x = "Times Measured", y = "Density", title = NULL) +  # Set labels
    xlim(0, 50)  # Set x-axis limits
}

# Apply the function to df_final
create_separate_density_plots(df_final)
```




```{r}
###measurment points ----
# Function to create stacked density plots for each category
create_stacked_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = times_measured_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d(name = "Category") +  # Use Viridis color palette and set legend title
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank()) +  # Remove grid lines and borders
    labs(x = "Times Measured", y = "Density", title = NULL) +  # Set labels
    xlim(0, 50)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots(df_final)
```


```{r}
# Function to create stacked density plots for each category
create_stacked_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = times_measured_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d(name = "Category") +  # Use Viridis color palette and set legend title
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Times Measured", y = "Density", title = NULL) +  # Set labels
    xlim(2, 10)  # Set x-axis limits
}
# Apply the function to df_final
create_stacked_density_plots(df_final)
```


```{r}
# Function to create stacked density plots for each category
create_stacked_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = sample_size_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d(name = "Category") +  # Use Viridis color palette and set legend title
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Sample Size", y = "Density", title = NULL) +  # Set labels
    xlim(0, 1000)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots(df_final)
```



```{r}
### publishing year---
create_stacked_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = publication_year, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Use Viridis color palette for fill
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Publication Year", y = "Density", title = NULL)  # Set labels
}

# Apply the function to df_final
create_stacked_density_plots(df_final)
```


```{r}
###item number----
create_stacked_density_plots_item <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = item_number_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Use Viridis color palette for fill
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Item Number", y = "Density", title = NULL) +  # Set labels
    xlim(1, 10)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots_item(df_final)
```


```{r}
###time measured----
create_stacked_density_plots_item <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = times_measured_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Use Viridis color palette for fill
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Times Measured", y = "Density", title = NULL) +  # Set labels
    xlim(1, 10)  # Set x-axis limits
}
# Apply the function to df_final
create_stacked_density_plots_item(df_final)
```



## Temporal Analysis
```{r}
# temporal analysis 
create_combined_horizontal_bar_temporal <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "variable", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Create a new factor for temporal analysis column
  df_long$factor_combined <- as.factor(df_long$temporal_analysis_1)
  
  # Plotting the horizontal bar plot using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = variable, fill = factor_combined)) +
    geom_bar(position = "fill", stat = "count", color = "white") +
    coord_flip() +  # Flip the coordinates for a horizontal bar plot
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(),
          axis.text.x = element_blank(), axis.title.x = element_blank()) +  # Remove x-axis labels and title
    labs(x = NULL, y = NULL, title = NULL) +  # Remove axis labels and change title
    scale_fill_viridis_d(name = "Temporal Analysis", labels = c(
      "No Analysis",
      "Analyzed"
    ))  # Use Viridis color palette and customize legend title
}
# Apply the function to df_final
create_combined_horizontal_bar_temporal(df_final)
```


```{r}
#correlation plot (correlation&time interval)----

##create a dataframe with all the correlations for a better overview.----

# Combine the correlation results columns into one
correlation_results <- c(df_final$correlation_results_1, df_final$correlation_results_1.1,
                         df_final$correlation_results_1.2, df_final$correlation_results_1.3,
                         df_final$correlation_results_1.4, df_final$correlation_results_1.5,
                         df_final$correlation_results_1.6, df_final$correlation_results_1.7,
                         df_final$correlation_results_1.8)

# Create a dataframe with two columns: correlation_results and test_retest_interval_1
correlation_1 <- data.frame(correlation_results, `test-retest_interval_1` = df_final$`test-retest_interval_1`)

colnames(correlation_1) <- c("correlation_results", "correlation_interval_1")

# Remove rows with NAs from correlation dataframe
correlation_1 <- na.omit(correlation_1)



# Combine the correlation_2 results columns into one
correlation_results <- c(df_final$correlation_results_2)

# Create a dataframe with two columns: correlation_results and test_retest_interval_1
correlation_2 <- data.frame(correlation_results, `test-retest_interval_2` = df_final$`test-retest_interval_2`)

colnames(correlation_2) <- c("correlation_results", "correlation_interval_1")

correlation_2 <- na.omit(correlation_2)



# Combine the correlation_3 results columns into one
correlation_results <- c(df_final$correlation_results_3)

# Create a dataframe with two columns: correlation_results and test_retest_interval_1
correlation_3 <- data.frame(correlation_results, `test-retest_interval_3` = df_final$`test-retest_interval_3`)

colnames(correlation_3) <- c("correlation_results", "correlation_interval_1")

correlation_3 <- na.omit(correlation_3)



# Combine the correlation_4 results columns into one
correlation_results <- c(df_final$correlation_results_4)

# Create a dataframe with two columns: correlation_results and test_retest_interval_1
correlation_4 <- data.frame(correlation_results, `test-retest_interval_4` = df_final$`test-retest_interval_4`)

colnames(correlation_4) <- c("correlation_results", "correlation_interval_1")

correlation_4 <- na.omit(correlation_4)



# Combine the correlation_5 results columns into one
correlation_results <- c(df_final$correlation_results_5)

# Create a dataframe with two columns: correlation_results and test_retest_interval_1
correlation_5 <- data.frame(correlation_results, `test-retest_interval_5` = df_final$`test-retest_interval_5`)

colnames(correlation_5) <- c("correlation_results", "correlation_interval_1")

correlation_5 <- na.omit(correlation_5)



# Assuming correlation_2 has the same structure as correlation (two columns: correlation_results and correlation_interval_1)
correlation <- rbind(correlation_1, correlation_2, correlation_3, correlation_4, correlation_5 )
```


```{r, warning=FALSE}
###plot----
# Plot the two columns against each other with x-axis limited to 800 and a correlation line
ggplot(correlation, aes(x = correlation_interval_1, y = correlation_results)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = viridis(1)) + # Add correlation line
  labs(x = "Correlation Interval", y = "Correlation Results") +
  xlim(0, 800) +
  ylim(0,1)
```


```{r, warning=FALSE}
# Calculate correlation coefficient
correlation_coefficient <- cor(correlation$correlation_interval_1, correlation$correlation_results)

# Plot the two columns against each other with x-axis limited to 800 and a correlation line
ggplot(correlation, aes(x = correlation_interval_1, y = correlation_results)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = viridis(1)) + # Add correlation line
  annotate("text", x = 400, y = 0.75, 
           label = paste("Correlation coefficient:", round(correlation_coefficient, 2)), 
           color = viridis(1), size = 4) +  # Add correlation coefficient annotation
  labs(x = "Correlation Interval", y = "Correlation Results") +
  xlim(0, 800) +
  ylim(0, 1)
  theme(panel.background = element_rect(fill = "white"))  # Set background color to white


####minimal indication that over time the correlation coefficient decreases. 

```


```{r}
####correlation plotting with time interval
# Create a scatter plot with a correlation line
ggplot(df_final, aes(x = `test-retest_interval_1`, y = correlation_results_1, color = as.factor(health))) +
  geom_point() +  # Scatter plot
  geom_smooth(method = "lm", se = FALSE, color = viridis(1)) +  # Add a linear regression line
  scale_color_viridis_d(name = "Health") +  # Use Viridis color palette and set legend title
  theme_minimal() +  # Minimal theme
  labs(x = "Time Interval in days", y = "Correlation Results", title = NULL) +
  ylim(0, 1)
```


```{r}
# Create a scatter plot with a correlation line
ggplot(df_final, aes(x = `test-retest_interval_1`, y = correlation_results_1, color = as.factor(health))) +
  geom_point() +  # Scatter plot
  geom_smooth(method = "lm", se = FALSE, color = viridis(1)) +  # Add a linear regression line
  scale_color_viridis_d(name = "Health") +  # Specify color for health values and set legend title
  theme_minimal() +  # Minimal theme
  theme(
    panel.background = element_rect(fill = "white"),  # Set background color to white
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Set axis line color
    legend.position = "bottom"  # Position legend at the bottom
  ) +
  labs(x = "Time Interval in days", y = "Correlation Results", title = NULL) +  # Set axis labels and title
  ylim(0, 1)  # Set y-axis limits
```


```{r}
###create a density plot for days apart between the measurement------
# Create a new column by combining values from the three columns
df_final <- df_final %>%
  mutate(combined_column = paste(`test-retest_interval_1`, `temporal_trend_interval_1`, `mean_difference_interval_1`, sep = "_")) %>%
  mutate(combined_column = as.numeric(gsub("[^0-9.]", "", combined_column)))

# Function to create stacked density plots for each category with Viridis color scale
create_stacked_density_plots <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = combined_column, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Use Viridis color palette for fill
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Time Interval", y = "Density", title = NULL) +  # Set labels
    xlim(2, 1000)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots(df_final)
```



## Population Characteristics
```{r}
###female male----
create_stacked_density_plots_item <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2 with Viridis color scale
  ggplot(df_long, aes(x = prop_female_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Use Viridis color palette for fill
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "Female Percentage", y = "Density", title = NULL) +  # Set labels
    xlim(0, 1)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots_item(df_final)
```


```{r}
###age (age and age category)----
# Convert the column to numeric
df_final$mean_age_1 <- as.numeric(df_final$mean_age_1)
create_stacked_density_plots_item <- function(df) {
  columns_of_interest <- c('health', 'finance', 'political', 'crime', 'nature', 'nuclear', 'social')
  
  # Create a long-format data frame for ggplot
  df_long <- df %>%
    gather(key = "category", value = "value", columns_of_interest) %>%
    filter(value == 1)  # Filter only rows where the value is 1
  
  # Plotting the stacked density plots using ggplot2
  ggplot(df_long, aes(x = mean_age_1, fill = category)) +
    geom_density(alpha = 0.5) +  # Density plot with transparency
    facet_grid(category ~ ., scales = "free_x", switch = "y") +  # Stacked plots with category names on the y-axis
    scale_fill_viridis_d() +  # Specify colors for each category
    theme_minimal() +
    theme(panel.grid = element_blank(), panel.border = element_blank(), axis.text.y = element_blank()) +  # Remove grid lines, borders, and y-axis text
    labs(x = "mean age", y = "Density", title = NULL) +  # Set labels
    xlim(4, 70)  # Set x-axis limits
}

# Apply the function to df_final
create_stacked_density_plots_item(df_final)
```



